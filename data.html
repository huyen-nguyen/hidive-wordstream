<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
    <meta content="HIDIVE WordStream" name="description"/>
    <meta content="Huyen Nguyen" name="author"/>
    <title>WordStream</title>
    <script src="js/d3.v4.min.js"></script>
    <script src="js/wordstream.js"></script>
    <link href="styles/main.css" rel="stylesheet"/>

</head>
<body>
<h1>The evolution of topics from HIDIVE Lab publication titles</h1>
<p>Stream height is proportional to the corresponding number of publications.</p>
<script>
    // WordStream Configuration
    let svg = d3.select("body").append('svg')
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

    let config = {
        topWord: 60,
        minFont: 10,
        maxFont: 30,
        tickFont: 12,
        legendFont: 12,
        curve: d3.curveCardinal
    };

    // HIDIVE data
    const taxonomy = {
        'Cell': ["Cell", "Cell Reports", "Cancer Cell", "Cell Systems", "Histochemistry and Cell Biology"],

        'Visualization': ["IEEE Transactions on Visualization and Computer Graphics", "Computer Graphics Forum","2023 IEEE Visualization and Visual Analytics (VIS)", "Poster Compendium of the IEEE Conference on Information Visualization (InfoVis’ 15)", "Information Visualization", "IEEE Symposium on Biological Data Visualization 2011", "Proceedings of the IEEE Information Visualization Conference–Posters (InfoVis’ 19)", "Poster Compendium of the IEEE VIS Conference. IEEE", "2023 IEEE VIS Workshop on Visualization Education, Literacy, and Activities (EduVis)", "IEEE Computer Graphics and Applications", "EuroVis 2016 - Posters", "Proceedings of the 2023 CHI Conference on Human Factors in Computing Systems", "2019 IEEE Visualization Conference (VIS)"],

        "Bioinformatics": ["Bioinformatics", "BMC Bioinformatics", "PLoS Computational Biology", "Biocomputing 2021", "Bioinformatics (Oxford, England)", "Journal of Biomedical Informatics", "Biocomputing 2016: Proceedings of the Pacific Symposium", ],

        'Nature': ["Nature", "Nature Methods", "Nature Genetics", "Nature Communications", "Nature Medicine", "Nature Cell Biology", "Nature Biotechnology", "Nature Aging"],
    }

    // Misc
    const stopWords = [
        "a", "about", "above", "after", "again", "against", "all", "am", "an", "and",
        "any", "are", "aren't", "as", "at", "be", "because", "been", "before",
        "being", "below", "between", "both", "but", "by", "can't", "cannot",
        "could", "couldn't", "did", "didn't", "do", "does", "doesn't", "doing",
        "don't", "down", "during", "each", "few", "for", "from", "further", "had",
        "hadn't", "has", "hasn't", "have", "haven't", "having", "he", "he'd",
        "he'll", "he's", "her", "here", "here's", "hers", "herself", "him",
        "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've", "if",
        "in", "into", "is", "isn't", "it", "it's", "its", "itself", "let's", "me",
        "more", "most", "mustn't", "my", "myself", "no", "nor", "not", "of", "off",
        "on", "once", "only", "or", "other", "ought", "our", "ours", "ourselves",
        "out", "over", "own", "same", "shan't", "she", "she'd", "she'll", "she's",
        "should", "shouldn't", "so", "some", "such", "than", "that", "that's",
        "the", "their", "theirs", "them", "themselves", "then", "there", "there's",
        "these", "they", "they'd", "they'll", "they're", "they've", "this", "those",
        "through", "to", "too", "under", "until", "up", "very", "was", "wasn't",
        "we", "we'd", "we'll", "we're", "we've", "were", "weren't", "what",
        "what's", "when", "when's", "where", "where's", "which", "while", "who",
        "who's", "whom", "why", "why's", "with", "won't", "would", "wouldn't",
        "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself",
        "yourselves", "ain", "aren", "couldn", "didn", "doesn", "hadn", "hasn",
        "haven", "isn", "ma", "mightn", "mustn", "needn", "shan", "shouldn",
        "wasn", "weren", "won", "wouldn", "dont"
    ];
    const other = 'Others'

    // Load data
    d3.csv("data/hidive/data.csv", function (row){
        return {                                    // renaming columns
            key: row["Key"],
            year: +row["Publication Year"],
            authors: row["Author"],
            title: row["Title"],
            venue: row["Publication Title"],
            DOI: row["DOI"],
            URL: row["Url"]
        };
    }, function (error, data){
        if (error) throw error;

        console.log(data)

        const groupedData = d3.nest()
            .key(d => +d.year)      // group by year
            .key(d => {               // group by venue type
            if (taxonomy["Nature"].includes(d.venue)) return "Nature";
            else if (taxonomy["Visualization"].includes(d.venue)) return "Visualization";
            else if (taxonomy["Cell"].includes(d.venue)) return "Cell";
            else if (taxonomy["Bioinformatics"].includes(d.venue)) return "Bioinformatics";
            else return other
        })
            .entries(data).sort((a,b) => +a.key - +b.key)
        console.log("groupedData", groupedData);

        // restructure to put into WS format
        const restructured = groupedData.map((group, timeIndex) => {
            let wordsByCategory = {};
            let recordsByCategory = {};
            const categories = [...Object.keys(taxonomy), other];

            // Iterate over each category
            categories.forEach(category => {
                const matchingCategory = group.values.filter(value => value.key === category);
                wordsByCategory[category] = matchingCategory.length ? processTitle(matchingCategory[0].values, category, timeIndex) : [];
                recordsByCategory[category] = matchingCategory.length ? matchingCategory[0].values.length : 0;
            });

            // Return the restructured object with date and categorized words
            return {
                date: group.key,         // The key of the group (date)
                words: wordsByCategory,   // The object with words categorized by taxonomy
                records: recordsByCategory
            };
        });

        console.log("restructured", restructured)

        wordstream(svg, restructured, config)

    });

    function processTitle(array2, category, timeIndex){
        const concatenatedTitles = array2.map(d => d.title).join(" ")
        const wordsArray = cleanAndTokenizeText(concatenatedTitles)
        return countWordFrequency(wordsArray, category, timeIndex)
    }

    function cleanAndTokenizeText(text){
        // remove punctuation
        const cleanedText = text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g, "");

        // convert to lowercase
        const lowerCaseText = cleanedText.toLowerCase();

        // tokenize the text into words (split by whitespace)
        const wordsArray = lowerCaseText.split(/\s+/)
            .filter(word => word.length > 0)                            //  remove empty strings
            .filter(word => !stopWords.includes(word.toLowerCase()));   // remove stopwords

        return wordsArray;
    }

    function countWordFrequency(wordsArray, category, timeIndex){
        let checkExistence = {};
        let boxCount = [];
        wordsArray.forEach(w => {
            if (!checkExistence[w]) { // have not existed
                checkExistence[w] = true
                let word = {
                    "text": w,
                    "frequency": 1,
                    "topic": category,
                    "id": w + "_" + category + "_" + timeIndex
                }
                boxCount.push(word);
            }

            else { // increment
                boxCount.find(word => word.text === w)["frequency"] += 1;
            }
        })
        return boxCount.sort((a,b) => b.frequency - a.frequency);
    }

</script>
</body>
</html>
